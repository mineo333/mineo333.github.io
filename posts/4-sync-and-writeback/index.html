<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="sync and Writeback" /><meta property="og:locale" content="en" /><meta name="description" content="In this article, I want to describe the sync syscall. By describing the sync, I hope to describe how changes to files are transferred from the page cache to the disk. This will give critical insight into how Qogchamp works." /><meta property="og:description" content="In this article, I want to describe the sync syscall. By describing the sync, I hope to describe how changes to files are transferred from the page cache to the disk. This will give critical insight into how Qogchamp works." /><link rel="canonical" href="https://mineo333.dev/posts/4-sync-and-writeback/" /><meta property="og:url" content="https://mineo333.dev/posts/4-sync-and-writeback/" /><meta property="og:site_name" content="mineo333/Sharad Khanna" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-11-20T22:40:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="sync and Writeback" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"sync and Writeback","dateModified":"2022-04-30T21:27:43+00:00","datePublished":"2021-11-20T22:40:00+00:00","description":"In this article, I want to describe the sync syscall. By describing the sync, I hope to describe how changes to files are transferred from the page cache to the disk. This will give critical insight into how Qogchamp works.","url":"https://mineo333.dev/posts/4-sync-and-writeback/","mainEntityOfPage":{"@type":"WebPage","@id":"https://mineo333.dev/posts/4-sync-and-writeback/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>sync and Writeback | mineo333/Sharad Khanna</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="mineo333/Sharad Khanna"><meta name="application-name" content="mineo333/Sharad Khanna"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/prof_pic.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">mineo333/Sharad Khanna</a></div><div class="site-subtitle font-italic">constantly in need of sleep</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/mineo333" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sharad','mineo333.dev'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/khanna-sharad/" aria-label="linkedin" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://stackoverflow.com/users/8877217/sharad-khanna" aria-label="stack-overflow" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>sync and Writeback</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>sync and Writeback</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> mineo333/Sharad Khanna </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Nov 20, 2021, 10:40 PM +0000" >Nov 20, 2021<i class="unloaded">2021-11-20T22:40:00+00:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Apr 30, 2022, 5:27 PM -0400" >Apr 30<i class="unloaded">2022-04-30T21:27:43+00:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2345 words">13 min read</span></div></div><div class="post-content"><p>In this article, I want to describe the <code class="language-plaintext highlighter-rouge">sync</code> syscall. By describing the <code class="language-plaintext highlighter-rouge">sync</code>, I hope to describe how changes to files are transferred from the page cache to the disk. This will give critical insight into how Qogchamp works.</p><h2 id="how-to-read-this-article">How to read this article</h2><p>This article goes step by step through the <code class="language-plaintext highlighter-rouge">msync</code> and <code class="language-plaintext highlighter-rouge">fsync</code> syscalls. I HIGHLY recommend that you follow along on your own as I don’t put much of the actual code in this article. In order to follow along either start at the entrypoints mentioned, or, if you’re skipping around, use <a href="https://elixir.bootlin.com/linux/v5.14/source">this</a> wonderful website to search look up the symbols.</p><h2 id="entrypoint">Entrypoint</h2><p>In order to begin analyzing <code class="language-plaintext highlighter-rouge">sync</code>, it is important to find the entrypoint. Luckily, we can use <a href="https://filippo.io/linux-syscall-table/">this</a> wonderful site that describes all the entrypoints for each syscall and their registers.</p><p>Looking at this site, we find three kinds of <code class="language-plaintext highlighter-rouge">sync</code> - <code class="language-plaintext highlighter-rouge">msync</code>, <code class="language-plaintext highlighter-rouge">fsync</code>, and plain <code class="language-plaintext highlighter-rouge">sync</code>. For ease, we will analyze both <code class="language-plaintext highlighter-rouge">msync</code> and <code class="language-plaintext highlighter-rouge">fsync</code>. We won’t analyze <code class="language-plaintext highlighter-rouge">sync</code> because it wakes up the flusher threads, which makes it somewhat difficult to analyze.</p><h2 id="msync-vs-fsync">msync vs. fsync</h2><p>I briefly want to go over the difference between <code class="language-plaintext highlighter-rouge">msync</code> and <code class="language-plaintext highlighter-rouge">fsync</code> at a high level before we get into the specifics.</p><p>There are two ways to open and modify files for those unaware: <code class="language-plaintext highlighter-rouge">write</code> and <code class="language-plaintext highlighter-rouge">mmap</code>.</p><p>In the case of <code class="language-plaintext highlighter-rouge">write</code>, we simply open the file using <code class="language-plaintext highlighter-rouge">open</code>, and then we use <code class="language-plaintext highlighter-rouge">write</code> along with the returned file descriptor. In the case of <code class="language-plaintext highlighter-rouge">write</code>, as we will see, the changes are written directly to the backing <code class="language-plaintext highlighter-rouge">struct address_space</code> of the inode. In order manually to force the contents of the written file back to the disk, we use <code class="language-plaintext highlighter-rouge">fsync</code>, which takes in the file descriptor received from <code class="language-plaintext highlighter-rouge">open</code>.</p><p>In the case of <code class="language-plaintext highlighter-rouge">mmap</code>, we map the file into the process’s address space. Meaning, we can access and modify portions of the file in the same way we might access portions of stack or heap. These modifications are then written back to the page cache. <code class="language-plaintext highlighter-rouge">msync</code> is used to force back those changes to the disk.</p><h2 id="fsync">fsync</h2><p>Using the site mentioned above, we can find the entry point of <code class="language-plaintext highlighter-rouge">fsync</code>, which happens to be in fs/sync.c which can be found <a href="https://elixir.bootlin.com/linux/v5.14/source/fs/sync.c#L230">here</a>. In order to find the actual syscall within the file, we can look for the <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINEx</code> macro.</p><p>Quickly, we find that we enter a function called <code class="language-plaintext highlighter-rouge">do_fsync</code> with the <code class="language-plaintext highlighter-rouge">fd</code> and another argument <code class="language-plaintext highlighter-rouge">datasync</code> being 0. <code class="language-plaintext highlighter-rouge">datasync</code> is only set to 1 if <code class="language-plaintext highlighter-rouge">fdatasync</code> is called.</p><p>Within <code class="language-plaintext highlighter-rouge">do_fsync</code> we call <code class="language-plaintext highlighter-rouge">fdget</code> which returns a <code class="language-plaintext highlighter-rouge">struct fd</code>. Those familiar with Linux file operations might recognize this function. Essentially, within the process control block of Linux - <code class="language-plaintext highlighter-rouge">struct task_struct</code> there is an array of <code class="language-plaintext highlighter-rouge">struct fd</code>s containing information on opened files. Using this integer as an index into this array, we get the relevant <code class="language-plaintext highlighter-rouge">struct fd</code>. If you’re particularly interested in these functions, I recommend reading <a href="https://www.kernel.org/doc/Documentation/file-systems/files.txt">this</a>.</p><p>Using this <code class="language-plaintext highlighter-rouge">struct fd</code>, we enter another function known as <code class="language-plaintext highlighter-rouge">vfs_fsync</code>. Anyone familiar with Linux file operations might be familiar with the <code class="language-plaintext highlighter-rouge">vfs_</code> prefix. This is derived the idea of the virtual file system. In the Linux Kernel, we have a generic high-level file-system which functions as the abstraction above concrete file systems (i.e. ext4). As we’ll see, these <code class="language-plaintext highlighter-rouge">vfs_</code> functions typically eventually call file-systems-specific functions.</p><p>In <code class="language-plaintext highlighter-rouge">vfs_fsync</code> we call <code class="language-plaintext highlighter-rouge">vfs_fsync_range</code> which is used to sync portions of a file. We use 0 and <code class="language-plaintext highlighter-rouge">LLONG_MAX</code> as the start and end, respectively, to sync the entire file. From here, we move into file-system-specific operations.</p><p>In <code class="language-plaintext highlighter-rouge">vfs_fsync_range</code>, we begin with two if-statements. The first if-statement checks if the file system has a fsync member function. If not, then it errors. This happens because the virtual file system needs a concrete <code class="language-plaintext highlighter-rouge">fsync</code> function provided by the file-system in order to perform <code class="language-plaintext highlighter-rouge">fsync</code>.</p><p>The second if-statement is a little more peculiar. The second if-statement is where <code class="language-plaintext highlighter-rouge">datasync</code> becomes useful. If <code class="language-plaintext highlighter-rouge">datasync</code> is 0 (Which it is), then we essentially update the inode metadata and write that new metadata to the disk. If <code class="language-plaintext highlighter-rouge">datasync</code> is 1, then we do not update the metadata, and we only sync the contents of the file.</p><p>When those two checks are complete, we finally call the file-system-specific <code class="language-plaintext highlighter-rouge">fsync</code>.</p><p>Unfortunately, because of how many file-systems there are, I will not be able to cover the <code class="language-plaintext highlighter-rouge">fsync</code> implementation for every single one. So, I will only focus on ext4’s implementation, which can be found <a href="https://elixir.bootlin.com/linux/v5.14/source/fs/ext4/file.c#L912">here</a>. Looking at the <code class="language-plaintext highlighter-rouge">fsync</code> field, we find that it points to <code class="language-plaintext highlighter-rouge">ext4_sync_file</code>. This is what is called by <code class="language-plaintext highlighter-rouge">vfs_fsync_range</code>.</p><h2 id="file-system-specific-fsync">File-system-Specific fsync</h2><p>In <code class="language-plaintext highlighter-rouge">ext4_sync_file</code>, we start out by checking if the superblock of the file-system is read only. If it is then we leave (<code class="language-plaintext highlighter-rouge">goto out</code>). This is fairly self-explanatory as we can’t write to a read-only file-system.</p><p>After that check is completed, we immediately jump into <code class="language-plaintext highlighter-rouge">file_write_and_wait_range</code>, which actually happens to be a VFS function. In <code class="language-plaintext highlighter-rouge">file_write_and_wait_range</code>, we come across a familiar data structure: <code class="language-plaintext highlighter-rouge">address_space</code>, which, as you might recall, is the page cache data structure. As might be obvious, we are going to write the pages from <code class="language-plaintext highlighter-rouge">address_space</code>.</p><p>The first thing that we check in <code class="language-plaintext highlighter-rouge">file_write_and_wait_range</code> is if the page-cache has any pages at all. This is done by running the function <code class="language-plaintext highlighter-rouge">mapping_needs_writeback</code>. This is an important check because if the page cache has no pages, then what’s the point of starting writeback?</p><p>If the page cache for the inode does indeed have pages, we run <code class="language-plaintext highlighter-rouge">__filemap_fdatawrite_range</code>. <code class="language-plaintext highlighter-rouge">__filemap_fdatawrite_range</code> is run with four parameters. The first three are self-explanatory. The last one is interesting, however: <code class="language-plaintext highlighter-rouge">WB_SYNC_ALL</code>. What this flag does is that if a page in the page cache is already under writeback, then it should wait for the writeback to finish and then redo the writeback. The alternative to this is <code class="language-plaintext highlighter-rouge">WB_SYNC_NONE</code>, which does not wait for writeback to complete and instead skips any page currently under writeback. This distinction is best described in the documentation for <code class="language-plaintext highlighter-rouge">__filemap_fdatawrite_range</code>, which says that “The difference between [ <code class="language-plaintext highlighter-rouge">WB_SYNC_NONE</code> and <code class="language-plaintext highlighter-rouge">WB_SYNC_ALL</code> ] is that if a dirty page/buffer is encountered, it must be waited upon, and not just skipped over.” We will see these flags in the code down the road.</p><p>Looking into <code class="language-plaintext highlighter-rouge">__filemap_fdatawrite_range</code> we see that we setup something called a <code class="language-plaintext highlighter-rouge">writeback_control</code>. This struct essentially decides how writeback will be done. There are 4 fields populated, but one that is new: <code class="language-plaintext highlighter-rouge">nr_to_write</code>. This represents the number of pages to writeback. This is set to <code class="language-plaintext highlighter-rouge">LONG_MAX</code>, indicating that we should writeback all pages (Which makes sense). Once that is set up, we jump into <code class="language-plaintext highlighter-rouge">do_writepages</code>.</p><p>Within <code class="language-plaintext highlighter-rouge">do_writepages</code>, we arrive a fork in the road. If the file-system has an implementation for <code class="language-plaintext highlighter-rouge">writepages</code> in its <code class="language-plaintext highlighter-rouge">address_space_operations</code> then use that. If not, then use a <code class="language-plaintext highlighter-rouge">generic_writepages</code>. Looking into ext4’s <code class="language-plaintext highlighter-rouge">address_space_operations</code>, we see that ext4 has an implementation for <code class="language-plaintext highlighter-rouge">writepages</code> in <code class="language-plaintext highlighter-rouge">ext4_writepages</code>. So, we jump to that function.</p><h2 id="writepages">writepages</h2><p>Upon reading <code class="language-plaintext highlighter-rouge">ext4_writepages</code>, we see a daunting block of code. However, upon closer analysis, it becomes obvious that much of this code is for dealing with special cases of writeback - specifically three cases: cyclic writeback, inline file writeback, and non-journaled writeback. However, for ease, we will assume that we take the standard writeback procedure which uses journaling</p><p>Assuming we are performing journaling, we start at line 2671. Here, we first check if the file is being journaled. If it is (Which we are assuming), then we jump to <code class="language-plaintext highlighter-rouge">generic_writepages</code>.</p><p>Within <code class="language-plaintext highlighter-rouge">generic_writepages</code>, we start by looking checking if the file-system’s <code class="language-plaintext highlighter-rouge">address_space_operations</code> has a <code class="language-plaintext highlighter-rouge">writepage</code> implementation. If it doesn’t then leave. This <code class="language-plaintext highlighter-rouge">writepage</code> function is what actually writes the new file buffer to the disk. So, without a <code class="language-plaintext highlighter-rouge">writepage</code> it is physically impossible to push data to the disk. If <code class="language-plaintext highlighter-rouge">writepage</code> exists, we then run a function called <code class="language-plaintext highlighter-rouge">blk_start_plug</code>. According to the documentation, all this does is warm up the block device and block io layer and warn them that they will be receiving IO requests shortly. From here, we jump to <code class="language-plaintext highlighter-rouge">write_cache_pages</code>. However, before we go into <code class="language-plaintext highlighter-rouge">write_cache_pages</code>, we need to analyze one of the parameters - specifically <code class="language-plaintext highlighter-rouge">__writepage</code>.</p><p><code class="language-plaintext highlighter-rouge">write_cache_pages</code> requires a parameter that is of type <code class="language-plaintext highlighter-rouge">writepage_t</code>. This is a pointer to a <code class="language-plaintext highlighter-rouge">writepage</code> function. In this case, we use <code class="language-plaintext highlighter-rouge">__writepage</code> which essentially serves as a wrapper of the FS-specific implementation of <code class="language-plaintext highlighter-rouge">writepage</code>.</p><p>Looking into <code class="language-plaintext highlighter-rouge">write_cache_pages</code> we find a very large block of code. However, once again, much of this code is dealing with edge cases which we don’t particularly care about. The first real line of consequence (And perhaps the most important line in the entire <code class="language-plaintext highlighter-rouge">fsync</code> implementation) happens on line 2197. This is the line where the magic of QogChamp is defined. Assuming that the sync mode is <code class="language-plaintext highlighter-rouge">WB_SYNC_ALL</code> (Which it is), then we will jump into <code class="language-plaintext highlighter-rouge">tag_pages_for_writeback</code>.</p><p>In <code class="language-plaintext highlighter-rouge">tag_pages_for_writeback</code>, the kernel essentially searches through the page cache and tags all the dirty pages with a special tag that says that it needs to be written back. How does it do this? The answer hearkens back to the <code class="language-plaintext highlighter-rouge">i_pages</code> xarray structure within the <code class="language-plaintext highlighter-rouge">address_space</code> object. What it does is that it uses a special macro to find all entires that are marked with <code class="language-plaintext highlighter-rouge">PAGECACHE_TAG_DIRTY</code>. Every entry marked with this tag is then marked with <code class="language-plaintext highlighter-rouge">PAGECACHE_TAG_TOWRITE</code>, indicating that it should be written to the disk.</p><p>There are two questions posed from this. First, why do this? The main reason for doing this is written in the documentation for <code class="language-plaintext highlighter-rouge">tag_pages_for_writeback</code>. We do this additional marking in order to prevent livelocking, which could be caused by a process writing to the pages as we’re trying to do the writeback. Second, where does the <code class="language-plaintext highlighter-rouge">PAGECACHE_TAG_DIRTY</code> tag come from, and when is it set? This is the answer to this question that holds the key to why QogChamp works. This topic will be discussed further as we discuss the <code class="language-plaintext highlighter-rouge">mmap</code> and <code class="language-plaintext highlighter-rouge">write</code> implementations.</p><p>Once <code class="language-plaintext highlighter-rouge">tag_pages_for_writeback</code> returns, it can be assumed that all the pages ready for writeback are tagged and ready to go. From here, it’s just a matter of iterating through the pages and sending them on their way to the disk.</p><p>In order to iterate through the pages, we create a <code class="language-plaintext highlighter-rouge">pagevec</code>. This <code class="language-plaintext highlighter-rouge">pagevec</code> is then populated with the pages that we need to write back to the disk via <code class="language-plaintext highlighter-rouge">pagevec_lookup_range_tag</code>. With this, we have everything we need to writeback.</p><p>To writeback, the code does three checks:</p><ol><li><p>It checks if the page has been truncated under us. If so, then leave because a truncated page cannot be written back. This is accomplished by checking if the <code class="language-plaintext highlighter-rouge">address_space</code> associated with the page is still valid.</p><li><p>It checks if the page is no longer dirty. If the page is no longer dirty, then the page has been written back by someone else.</p><li><p>It checks if the page is already currently under writeback. If it is, then it waits for it to not be under writeback and then either continues or redoes the write depending on whether <code class="language-plaintext highlighter-rouge">WB_SYNC_ALL</code> or <code class="language-plaintext highlighter-rouge">WB_SYNC_NONE</code> is used.</p></ol><p>Once these three checks are satisfied, the dirty flag is cleared via <code class="language-plaintext highlighter-rouge">clear_page_dirty_for_io</code>, and then finally, we call writepage function that was passed in earlier (<code class="language-plaintext highlighter-rouge">__writepage</code>). As I said earlier, <code class="language-plaintext highlighter-rouge">__writepage</code> serves as a wrapper for the FS-specific <code class="language-plaintext highlighter-rouge">writepage</code> which in the case of ext4 is <code class="language-plaintext highlighter-rouge">ext4_writepage</code>.</p><p>I’m not going to go over <code class="language-plaintext highlighter-rouge">ext4_writepage</code>, but essentially what it does is that it passes the page down the block device driver, which then pushes the page to the disk via DMA. This completes the journey of the average <code class="language-plaintext highlighter-rouge">fsync</code>.</p><h2 id="msync">msync</h2><p>Luckily, the <code class="language-plaintext highlighter-rouge">msync</code> implementation is not too different from the <code class="language-plaintext highlighter-rouge">fsync</code>.</p><p>Much like with <code class="language-plaintext highlighter-rouge">fsync</code>, we at the entry for <code class="language-plaintext highlighter-rouge">msync</code> which can be found <a href="https://elixir.bootlin.com/linux/v5.14/source/mm/msync.c#L32">here</a>.</p><p><code class="language-plaintext highlighter-rouge">msync</code> starts out by performing some checks. There are a variety of checks here. We first check the flags and if any flags that are not <code class="language-plaintext highlighter-rouge">MS_ASYNC</code>, <code class="language-plaintext highlighter-rouge">MS_SYNC</code>, or <code class="language-plaintext highlighter-rouge">MS_INVALIDATE</code> are set then return immediately. Second we check to see if both <code class="language-plaintext highlighter-rouge">MS_ASYNC</code> and <code class="language-plaintext highlighter-rouge">MS_SYNC</code> are set. If they are then return. Finally, we check if the inputted address and offset are valid.</p><p>If these basic checks pass then we can start <code class="language-plaintext highlighter-rouge">msync</code>. <code class="language-plaintext highlighter-rouge">msync</code> starts out with <code class="language-plaintext highlighter-rouge">find_vma</code> which finds the <code class="language-plaintext highlighter-rouge">vm_area_struct</code> that contains the <code class="language-plaintext highlighter-rouge">start</code>. Now <code class="language-plaintext highlighter-rouge">find_vma</code> does the search in a particularly interesting (And quite perplexing) way. Within each <code class="language-plaintext highlighter-rouge">vm_area_struct</code> there are fields called <code class="language-plaintext highlighter-rouge">vm_start</code> and <code class="language-plaintext highlighter-rouge">vm_end</code>. <code class="language-plaintext highlighter-rouge">vm_start</code> represents the beginning virtual address of the vma and <code class="language-plaintext highlighter-rouge">vm_end</code> represents the ending virtual address of the vma. Now instead of checking that <code class="language-plaintext highlighter-rouge">vm_start</code> &lt;= <code class="language-plaintext highlighter-rouge">start</code> &lt; <code class="language-plaintext highlighter-rouge">vm_end</code>, it instead checks that <code class="language-plaintext highlighter-rouge">start &lt; vm_end</code> and returns the first vma that satisfies that condition. So, we need to do some additional checking within <code class="language-plaintext highlighter-rouge">msync</code>. Specifically, we make sure that <code class="language-plaintext highlighter-rouge">start &gt;= vm_start</code>.</p><p>If all these checks are satisfied, then we can actually begin. We start by calculating the portion of the file that we want to sync which is then stored in <code class="language-plaintext highlighter-rouge">fstart</code> and <code class="language-plaintext highlighter-rouge">fend</code>. With these in hand we perform yet another which checks if 1. we have a file, 2. we are syncing synchronously, and 3. the mapping is shared. If these three conditions are satisfied then we pass <code class="language-plaintext highlighter-rouge">fstart</code> and <code class="language-plaintext highlighter-rouge">fend</code> into <code class="language-plaintext highlighter-rouge">vfs_fsync_range</code> and we continue with the same <code class="language-plaintext highlighter-rouge">fsync</code> routine. Note that in the case of <code class="language-plaintext highlighter-rouge">fsync</code> we passed in 0 and <code class="language-plaintext highlighter-rouge">LLONG_MAX</code>, but this time we are passing in only <code class="language-plaintext highlighter-rouge">fstart</code> and <code class="language-plaintext highlighter-rouge">fend</code> as we are syncing only the portion of the file specified by the user.</p><h2 id="additional-comments">Additional comments</h2><p>As you might have realized, Linux employs a very modular system when it comes to implementation. As we talked about <code class="language-plaintext highlighter-rouge">fsync</code> we were interleaving between different “layers” of the kernel. Initially, we start out at the virtual file system (vfs) level which called the file-system-specific function which then called the block-device-specific functions.</p><p>This layering idea is something that is common across the entire linux kernel whether it be networking, file-systems, or anything else and is something that one should get used to.</p><h2 id="whats-next">What’s Next</h2><p>From here, we are going to discuss how <code class="language-plaintext highlighter-rouge">PAGECACHE_TAG_DIRTY</code> is set by discussing <code class="language-plaintext highlighter-rouge">mmap</code>, <code class="language-plaintext highlighter-rouge">write</code>, and page faulting.</p><h2 id="references">References</h2><p>ext4’s <code class="language-plaintext highlighter-rouge">address_space_operations</code> - <a href="https://elixir.bootlin.com/linux/v5.14/source/fs/ext4/inode.c#L3648">https://elixir.bootlin.com/linux/v5.14/source/fs/ext4/inode.c#L3648</a></p><p><code class="language-plaintext highlighter-rouge">find_vma</code> - <a href="https://elixir.bootlin.com/linux/v5.14/source/mm/mmap.c#L2301">https://elixir.bootlin.com/linux/v5.14/source/mm/mmap.c#L2301</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/qogchamp/'>QogChamp</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/linux-kernel-exploitation/" class="post-tag no-text-decoration" >Linux Kernel Exploitation</a> <a href="/tags/syscall/" class="post-tag no-text-decoration" >Syscall</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=sync and Writeback - mineo333/Sharad Khanna&url=https://mineo333.dev/posts/4-sync-and-writeback/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=sync and Writeback - mineo333/Sharad Khanna&u=https://mineo333.dev/posts/4-sync-and-writeback/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=sync and Writeback - mineo333/Sharad Khanna&url=https://mineo333.dev/posts/4-sync-and-writeback/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/4-sync-and-writeback/">sync and Writeback</a><li><a href="/posts/1-beginnings/">Beginnings</a><li><a href="/posts/2-paging-in-the-linux-kernel/">Paging in the Linux Kernel</a><li><a href="/posts/3-linux-kernel-page-cache/">Linux Kernel Page Cache</a><li><a href="/posts/what-is-qogchamp/">What is QogChamp?</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/linux-kernel-exploitation/">Linux Kernel Exploitation</a> <a class="post-tag" href="/tags/syscall/">Syscall</a> <a class="post-tag" href="/tags/mm/">MM</a> <a class="post-tag" href="/tags/page-cache/">Page Cache</a> <a class="post-tag" href="/tags/paging/">Paging</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/1-beginnings/"><div class="card-body"> <span class="timeago small" >Oct 26, 2021<i class="unloaded">2021-10-26T16:30:00+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Beginnings</h3><div class="text-muted small"><p> In this post, I hope to tell you about how QogChamp started and what the original codebase looked like. This will be a fairly brief post and won’t get too much into the codebase as the functions us...</p></div></div></a></div><div class="card"> <a href="/posts/A-Look-At-mmap-Part-1/"><div class="card-body"> <span class="timeago small" >Apr 30<i class="unloaded">2022-04-30T14:00:00+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>A Look At mmap - Part 1</h3><div class="text-muted small"><p> Disclaimer As always, nothing in this article is guaranteed to be accurate nor correct. If you see anything blatantly wrong or missing from these articles, do not hesitate to email me at sharad@m...</p></div></div></a></div><div class="card"> <a href="/posts/what-is-qogchamp/"><div class="card-body"> <span class="timeago small" >Oct 26, 2021<i class="unloaded">2021-10-26T13:46:00+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What is QogChamp?</h3><div class="text-muted small"><p> So, the primary reason I made this blog was to document and discuss the logic and code behind my rootkit: QogChamp. In this post, I want to answer the simple question: What is QogChamp? Through th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/3-linux-kernel-page-cache/" class="btn btn-outline-primary" prompt="Older"><p>Linux Kernel Page Cache</p></a> <a href="/posts/A-Look-At-mmap-Part-1/" class="btn btn-outline-primary" prompt="Newer"><p>A Look At mmap - Part 1</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="">mineo333/Sharad Khanna</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/linux-kernel-exploitation/">Linux Kernel Exploitation</a> <a class="post-tag" href="/tags/syscall/">Syscall</a> <a class="post-tag" href="/tags/mm/">MM</a> <a class="post-tag" href="/tags/page-cache/">Page Cache</a> <a class="post-tag" href="/tags/paging/">Paging</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
